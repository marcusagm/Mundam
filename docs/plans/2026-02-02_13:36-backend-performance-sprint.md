# Plan: Backend Performance Sprint (Completed)

> **Generated by:** Antigravity (Project Planner)
> **Date:** 2026-02-02
> **Context:** Detailed Execution Report for Backend Optimization

---

## 1. Overview
This document details the specific technical implementations executed during the **Backend Performance Sprint**. The primary objective was to eliminate O(N) database operations (Full Table Scans) for search and sort, replacing them with O(log N) indexed operations to improved scalability for libraries > 50,000 images.

## 2. Project Type
**Backend (Rust + SQLite)**

## 3. Success Criteria
-   [x] **Search Performance:** Text search (filename, notes) uses Inverted Index (FTS5) via `MATCH` operator.
-   [x] **Sort Performance:** Sorting by `rating`, `size`, `created_at` uses Compound B-Tree Indices.
-   [x] **Robustness:** Unknown search keys log warnings instead of silent failures.
-   [x] **Stability:** Recursive folder queries have a hard depth limit (50).

## 4. Technical Implementation Details

### A. SQLite FTS5 (Full-Text Search)
**File:** `src-tauri/src/schema.sql`

We implemented a "Contentless" FTS5 virtual table strategy to index text without duplicating the entire storage, kept in sync via Triggers.

1.  **Virtual Table Definition:**
    ```sql
    CREATE VIRTUAL TABLE IF NOT EXISTS images_fts USING fts5(
        filename, 
        notes, 
        content='images',      -- External content (references main table)
        content_rowid='id',    -- Maps to images.id
        tokenize='trigram'     -- Efficient substring matching (better than standard tokenizer)
    );
    ```

2.  **Sync Triggers:**
    *   `AFTER INSERT`: Inserts new row into `images_fts`.
    *   `AFTER DELETE`: Removes row from `images_fts`.
    *   `AFTER UPDATE`: Updates `images_fts` content.

### B. Rust Search Logic Refactoring
**File:** `src-tauri/src/search_logic.rs`

Refactored `build_criterion_clause` to conditionally use FTS vs Standard SQL.

1.  **Logic Switch:**
    ```rust
    let is_fts_target = (c.key == "filename" || c.key == "notes");
    ```

2.  **Query Construction (Contains):**
    *   **Old:** `LIKE %value%` (Scan)
    *   **New:** `id IN (SELECT rowid FROM images_fts WHERE key MATCH "value")` (Index Lookups)
    *   **Note:** We use `MATCH "value"` with Trigram tokenizer which implicitly handles substring matching properly without leading wildcards usage in the query string itself.

### C. Sorting Optimization
**File:** `src-tauri/src/schema.sql`

Added specific indices to support the most common sort orders in the UI:

*   `idx_images_rating_created`: `(rating DESC, created_at DESC)` -> For "Highest Rated" view.
*   `idx_images_modified`: `(modified_at DESC)` -> For "Recently Edited".
*   `idx_images_size`: `(size DESC)` -> For storage management.
*   `idx_images_created`: `(created_at DESC)` -> For "Newest First".

### D. Safety & Robustness
**File:** `src-tauri/src/search_logic.rs`

1.  **Recursion Limit:**
    *   Added `depth < 50` to the Common Table Expression (CTE) for recursive folder queries.
    *   Prevents application crash if user creates a circular folder reference (e.g., symlinks).

2.  **Date Parsing:**
    *   Added logic to detect `DD/MM/YYYY` format (via `/` check) and convert to ISO-8601 (`YYYY-MM-DD`) before binding to SQL.

3.  **Observability:**
    *   Added `println!("WARN: ...")` branches for unknown operators/keys instead of silently appending `1=1`.

## 5. Verification Checklist

| Check | Expected Result | Status |
|-------|-----------------|--------|
| **Schema Migration** | `images_fts` table exists in DB | ✅ Done |
| **Search (Text)** | Searching "vacation" maps to FTS `MATCH` query | ✅ Done |
| **Search (Format)** | Searching "jpg" still uses standard `LIKE` (correct fallback) | ✅ Done |
| **Sort speed** | Sorting 10k items by Rating is instant | ✅ Done |
| **Recursive** | Query planner uses depth limit | ✅ Done |

## 6. Pending Actions
*   None for this sprint. Proceed to **Integrity Sprint** (File Watchers).
